"use strict";

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.function.name");

require("core-js/modules/es6.reflect.delete-property");

require("core-js/modules/es6.promise");

require("core-js/modules/es6.regexp.split");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var path = require("path"),
    url = require("url"),
    fs = require("fs"),
    promisify = require("util.promisify"),
    _ = require("underscore"),
    color = require("tinycolor2"),
    cheerio = require("cheerio"),
    colors = require("colors"),
    jsonxml = require("jsontoxml"),
    sizeOf = require("image-size"),
    Jimp = require("jimp"),
    svg2png = require("svg2png"),
    File = require("vinyl"),
    Reflect = require("harmony-reflect"),
    PLATFORM_OPTIONS = require("./config/platform-options.json");

(function () {
  "use strict";

  var xmlconfig = {
    prettyPrint: true,
    xmlHeader: true,
    indent: "  "
  },
      HEX_MAX = 255,
      NON_EXISTANT = -1,
      ROTATE_DEGREES = 90;

  function helpers(options) {
    function directory(path) {
      return path.substr(-1) === "/" ? path : `${path}/`;
    }

    function relative(path) {
      return url.resolve(options.path && directory(options.path), path);
    }

    function print(context, message) {
      var newMessage = "";

      if (options.logging && message) {
        _.each(message.split(" "), function (item) {
          newMessage += ` ${/^\d+x\d+$/gm.test(item) ? colors.magenta(item) : item}`;
        });

        console.log(`${colors.green("[Favicons]")} ${context.yellow}:${newMessage}...`);
      }
    }

    return {
      General: {
        source(src) {
          print("General:source", `Source type is ${typeof src}`);

          if (Buffer.isBuffer(src)) {
            try {
              return Promise.resolve([{
                size: sizeOf(src),
                file: src
              }]);
            } catch (error) {
              return Promise.reject(new Error("Invalid image buffer"));
            }
          } else if (typeof src === "string") {
            return promisify(fs.readFile)(src).then(this.source.bind(this));
          } else if (Array.isArray(src) && !src.some(Array.isArray)) {
            if (!src.length) {
              return Promise.reject(new Error("No source provided"));
            }

            return Promise.all(src.map(this.source.bind(this))).then(function (results) {
              var _ref;

              return (_ref = []).concat.apply(_ref, _toConsumableArray(results));
            });
          } else {
            return Promise.reject(new Error("Invalid source type provided"));
          }
        },

        preparePlatformOptions(platform, options, baseOptions) {
          if (typeof options !== "object") {
            options = {};
          }

          _.each(options, function (value, key) {
            var platformOptionsRef = PLATFORM_OPTIONS[key];

            if (typeof platformOptionsRef === "undefined" || platformOptionsRef.platforms.indexOf(platform) === -1) {
              return Reflect.deleteProperty(options, key);
            }
          });

          _.each(PLATFORM_OPTIONS, function (_ref2, key) {
            var platforms = _ref2.platforms,
                defaultTo = _ref2.defaultTo;

            if (typeof options[key] === "undefined" && platforms.indexOf(platform) !== -1) {
              options[key] = defaultTo;
            }
          });

          if (typeof options.background === "boolean") {
            if (platform === "android" && !options.background) {
              options.background = "transparent";
            } else {
              options.background = baseOptions.background;
            }
          }

          if (platform === "android" && options.background !== "transparent") {
            options.disableTransparency = true;
          }

          return options;
        },

        background(hex) {
          print("General:background", `Parsing colour ${hex}`);
          var rgba = color(hex).toRgb();
          return Jimp.rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a * HEX_MAX);
        },

        /* eslint no-underscore-dangle: 0 */
        vinyl(object, input) {
          var output = new File({
            path: object.name,
            contents: Buffer.isBuffer(object.contents) ? object.contents : new Buffer(object.contents)
          }); // gulp-cache support

          if (typeof input._cachedKey !== "undefined") {
            output._cachedKey = input._cachedKey;
          }

          return output;
        }

      },
      HTML: {
        parse(html) {
          return new Promise(function (resolve) {
            print("HTML:parse", "HTML found, parsing and modifying source");
            var $ = cheerio.load(html),
                link = $("*").is("link"),
                attribute = link ? "href" : "content",
                value = $("*").first().attr(attribute);

            if (path.extname(value)) {
              $("*").first().attr(attribute, relative(value));
            } else if (value.slice(0, 1) === "#") {
              $("*").first().attr(attribute, options.background);
            } else if (html.indexOf("application-name") !== NON_EXISTANT || html.indexOf("apple-mobile-web-app-title") !== NON_EXISTANT) {
              $("*").first().attr(attribute, options.appName);
            }

            return resolve($.html());
          });
        }

      },
      Files: {
        create(properties, name, platformOptions) {
          return new Promise(function (resolve) {
            print("Files:create", `Creating file: ${name}`);

            if (name === "manifest.json") {
              properties.name = options.appName;
              properties.short_name = options.appName;
              properties.description = options.appDescription;
              properties.dir = options.dir;
              properties.lang = options.lang;
              properties.display = options.display;
              properties.orientation = options.orientation;
              properties.start_url = options.start_url;
              properties.background_color = options.background;
              properties.theme_color = options.theme_color;

              _.map(properties.icons, function (icon) {
                return icon.src = relative(icon.src);
              });

              properties = JSON.stringify(properties, null, 2);
            } else if (name === "manifest.webapp") {
              properties.version = options.version;
              properties.name = options.appName;
              properties.description = options.appDescription;
              properties.developer.name = options.developerName;
              properties.developer.url = options.developerURL;
              properties.icons = _.mapObject(properties.icons, function (property) {
                return relative(property);
              });
              properties = JSON.stringify(properties, null, 2);
            } else if (name === "browserconfig.xml") {
              _.map(properties[0].children[0].children[0].children, function (property) {
                if (property.name === "TileColor") {
                  property.text = platformOptions.background;
                } else {
                  property.attrs.src = relative(property.attrs.src);
                }
              });

              properties = jsonxml(properties, xmlconfig);
            } else if (name === "yandex-browser-manifest.json") {
              properties.version = options.version;
              properties.api_version = 1;
              properties.layout.logo = relative(properties.layout.logo);
              properties.layout.color = platformOptions.background;
              properties = JSON.stringify(properties, null, 2);
            } else if (/\.html$/.test(name)) {
              properties = properties.join("\n");
            }

            return resolve({
              name,
              contents: properties
            });
          });
        }

      },
      Images: {
        create(properties, background) {
          var _this = this;

          return new Promise(function (resolve, reject) {
            print("Image:create", `Creating empty ${properties.width}x${properties.height} canvas with ${properties.transparent ? "transparent" : background} background`);
            _this.jimp = new Jimp(properties.width, properties.height, properties.transparent ? 0x00000000 : background, function (error, canvas) {
              return error ? reject(error) : resolve(canvas);
            });
          });
        },

        render(sourceset, properties, offset) {
          print("Image:render", `Find nearest icon to ${properties.width}x${properties.height} with offset ${offset}`);

          var offsetSize = offset * 2,
              width = properties.width - offsetSize,
              height = properties.height - offsetSize,
              sideSize = Math.max(width, height),
              svgSource = _.find(sourceset, function (source) {
            return source.size.type === "svg";
          });

          var promise = null;

          if (svgSource) {
            print("Image:render", `Rendering SVG to ${width}x${height}`);
            promise = svg2png(svgSource.file, {
              height,
              width
            }).then(Jimp.read);
          } else {
            var nearestIcon = sourceset[0],
                nearestSideSize = Math.max(nearestIcon.size.width, nearestIcon.size.height);

            _.each(sourceset, function (icon) {
              var max = Math.max(icon.size.width, icon.size.height);

              if ((nearestSideSize > max || nearestSideSize < sideSize) && max >= sideSize) {
                nearestIcon = icon;
                nearestSideSize = max;
              }
            });

            print("Images:render", `Resizing PNG to ${width}x${height}`);
            promise = Jimp.read(nearestIcon.file).then(function (image) {
              return image.contain(width, height, Jimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE);
            });
          }

          return promise.then(function (image) {
            if (properties.rotate) {
              print("Images:render", `Rotating image by ${ROTATE_DEGREES}`);
              image.rotate(ROTATE_DEGREES, false);
            }

            return image;
          });
        },

        mask: Jimp.read(path.join(__dirname, "mask.png")),
        overlay: Jimp.read(path.join(__dirname, "overlay.png")),

        composite(canvas, image, properties, offset, max) {
          var _this2 = this;

          if (properties.mask) {
            print("Images:composite", "Masking composite image on circle");
            return Promise.all([this.mask, this.overlay]).then(function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 2),
                  mask = _ref4[0],
                  overlay = _ref4[1];

              canvas.mask(mask.clone().resize(max, Jimp.AUTO), 0, 0);
              canvas.composite(overlay.clone().resize(max, Jimp.AUTO), 0, 0);
              var properties = Object.assign({}, properties, {
                mask: false
              });
              return _this2.composite(canvas, image, properties, offset, max);
            });
          }

          print("Images:composite", `Compositing favicon on ${properties.width}x${properties.height} canvas with offset ${offset}`);
          return new Promise(function (resolve, reject) {
            return canvas.composite(image, offset, offset).getBuffer(Jimp.MIME_PNG, function (error, result) {
              return error ? reject(error) : resolve(result);
            });
          });
        }

      }
    };
  }

  module.exports = helpers;
})();